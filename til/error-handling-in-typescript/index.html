<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href="https://fonts.googleapis.com/css?family=Space+Mono|Work+Sans:300,400&display=swap" rel=stylesheet> <link href=favicon.ico rel=icon type=image/png> <link href=client/main.1851036717.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Error handling in Typescript</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-6s1izy><div class="svelte-6s1izy name"><h1><a href=/ class=svelte-1a59aal style='--theme-color:rgba(166, 186, 61, 0.5);--theme-content:"alex torres"'>alex torres</a></h1></div> <div class="svelte-6s1izy links"><h2 class=svelte-6s1izy><a href=/bio class=svelte-1a59aal style='--theme-color:rgba(254, 101, 1, 0.7);--theme-content:"bio"'>bio</a></h2> <h2 class=svelte-6s1izy><a href=/til class=svelte-1a59aal style='--theme-color:rgba(255, 237, 13, 1);--theme-content:"til"'>til</a></h2> <h2 class=svelte-6s1izy><a href=/photos class=svelte-1a59aal style='--theme-color:rgba(208, 13, 255, 0.5);--theme-content:"photos"'>photos</a></h2></div></nav> <main class=svelte-ggff4g> <div class="svelte-1eolez3 content"><h3 class=svelte-1eolez3>8/25/2021 Â· <a href="til?tag=typescript">#typescript</a> Â <a href="til?tag=software-development">#software-development</a> Â </h3> <h1 class=svelte-1eolez3>Error handling in Typescript</h1> <div class="svelte-1eolez3 post-html"><pre><code class="language-typescript typescript">const neverFailFunction = (input: number): number => {
  if (input === 0) {
    throw new Error('Oops, I failed')
  }

  return input * 2
}</code></pre> <p>One day, you or a colleague are using this function, you check the signature, and you see this <code>(input: number) => number</code>, so why should this fail?</p> <p>Obviously, this is not production code. But these things happens, you write a function that shouldn't fail, except for that particular edge case, time goes one, you forget about that case, and you use it without a <code>trycatch</code> statement. You might catch the error it somewhere in the stack, probably some layers upwards, and most of the time it's probably too late, you're missing a lot of context to treat the error properly.</p> <p>So what can we do to improve this? As of today, <a href=https://github.com/microsoft/TypeScript/issues/13219>Typescript is still missing checked exceptions</a></p> <p>If we'd had checked exceptions, we could write our function like this:</p> <pre><code class="language-typescript typescript">const neverFailFunction = (input: number): number throws Error => {
  if (input === 0) {
    throw new Error('Oops, I failed')
  }

  return input * 2
}</code></pre> <p>So we could easily take a look at the signature and know that this function may throw an error <code>(input: number) => number throws Error</code>. We could even enable a flag in the compiler in order to fail if we don't wrap throwable functions with <code>trycatch</code> clauses.</p> <p>So we will be enforced to treat the error where the error happens, with all the context needed.</p> <p>Until this becomes possible, if it ever happens, we can rely on other cool feature of Typescript: <strong>Union Types</strong>.</p> <h3 id=union-types-as-result-types>Union Types as Result Types</h3> <p>From Typescript documentation:</p> <blockquote> <p>A union type describes a value that can be one of several types. We use the vertical bar (|) to separate each type, so <code>number | string | boolean</code> is the type of a value that can be a <code>number</code>, a <code>string</code>, or a <code>boolean</code>.</p> </blockquote> <p>Great! Let's use this in our function:</p> <pre><code class="language-typescript typescript">const neverFailFunction = (input: number): number | Error => {
  if (input === 0) {
    return new Error('Oops, I failed')
  }

  return input * 2
}</code></pre> <p>And we can use it like this:</p> <pre><code class="language-typescript typescript">const otherFunction = (): void => {
  const result = neverFailFunction(1)

  if (result instanceof Error) {
    return console.error(result.message)
  }

  console.log('it worked', result) // it worked 1
}</code></pre> <p>This looks much nicer now. We have the full potential of Typescript, we returned an <code>number | Error</code> but we could be doing something like <code>number | ValidationError | InternalError</code> so we have really specialized errors instead of a generic <code>Error</code>.</p> <p>In the project I am currently working on we're using this approach a lot, but in order to even improve further the developer experience, we added some helper functions to make it easier work with external libraries and our own functions.</p> <p>First, we wrapped our functions results into a <code>Result</code> type:</p> <pre><code class="language-typescript typescript">export class ApplicationError extends Error {
  constructor(
    public readonly errorCode: string,
    description?: string
  ) {
    super(description || errorCode)

    // Need to override the prototype
    // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
    Object.setPrototypeOf(this, ApplicationError.prototype)
  }
}

export const fromError = (error: Error) => new ApplicationError('INTERNAL_ERROR', error.message)

export type Ok&lt;T> = {
  value: T
}

export const ok = &lt;T>(data: T): Ok&lt;T> => ({
  value: data
})

export type Result&lt;T, E extends ApplicationError = ApplicationError> = Ok&lt;T> | E
export type PromiseResult&lt;T, E extends ApplicationError = ApplicationError> = Promise&lt;Result&lt;T, E>>

export const isErrorResult = &lt;T = unknown, E extends ApplicationError = ApplicationError>(result: Result&lt;T, E>): result is E =>
  'errorCode' in result

export const isOkResult = &lt;T = unknown, E extends ApplicationError = ApplicationError>(result: Result&lt;T, E>): result is Ok&lt;T> =>
  'value' in result</code></pre> <p>So our function will become:</p> <pre><code class="language-typescript typescript">const neverFailFunction = (input: number): Result&lt;number, ApplicationError> => {
  if (input === 0) {
    return new ApplicationError('Oops, I failed')
  }

  return ok(input * 2)
}

const otherFunction = (): void => {
  const result = neverFailFunction(1)

  if (isErrorResult(result)) {
    return console.error(result.message)
  }

  console.log('it worked', result.value) // it worked 1
}</code></pre> <p>And finally, what if we have a native or 3rd party library that may throw an error? ðŸ¤” Well, we created also some useful helper methods to wrap those functions and translate the output to a result type, even if it throws an error:</p> <pre><code class="language-typescript typescript">/**
 * Expects a function that may throw. If it throws it returns the error passed
 */
export const fromAsyncTryCatch = &lt;O extends Error = Error, E extends ApplicationError = ApplicationError>(errorFn: (originalError: O) => E) =>
  async &lt;DataType>(fn: () => Promise&lt;DataType>): PromiseResult&lt;DataType, E> => {
    try {
      const res = await fn()

      return ok&lt;DataType>(res)
    } catch (catchErr) {
      return errorFn(catchErr)
    }
  }

export const fromTryCatch = &lt;O extends Error = Error, E extends ApplicationError = ApplicationError>(errorFn: (originalError: O) => E) =>
  &lt;DataType>(fn: () => DataType): Result&lt;DataType, E> => {
    try {
      const res = fn()

      return ok&lt;DataType>(res)
    } catch (catchErr) {
      return errorFn(catchErr)
    }
  }</code></pre> <p>So for instance, a common thing that throws is <code>JSON.parse</code>, so we could use it as:</p> <pre><code class="language-typescript typescript">const parse = &lt;T>(toParse: string): Result&lt;T, ApplicationError> => fromTryCatch(
  (error) => new ApplicationError('JSON parse failed', error.message)
)(() => JSON.parse(toParse))

const parsedResult = parse&lt;{ foo: number }>('{"foo":1}')

if (isErrorResult(parsedResult)) {
  return console.log('hack')
}

console.log(parsedResult.value.foo)</code></pre> <p>And to even make this easier, so we can avoid all the boilerplate, we added one more function:</p> <pre><code class="language-typescript typescript">export const effectiveError = fromAsyncTryCatch&lt;Error | ApplicationError, ApplicationError>(
  (error) => {
    if (error instanceof ApplicationError) {
      return error
    }

    return fromError(error)
  }
)</code></pre> <p>This is pretty handy, so you don't even need to think of wrapping your stuff into a Result:</p> <pre><code class="language-typescript typescript">const parseAndProcess = &lt;T>(toParse: string): PromiseResult&lt;T, ApplicationError> =>
  effectiveError(async () => {
    const parsedResult = JSON.parse(toParse)

    console.log(parsedResult.foo)

    if (parsedResult.foo === 1) {
      throw new ApplicationError('hack')
    }

    return parsedResult
  })</code></pre> <p>So you don't really need to care about wrapping or returning <code>Ok</code>, everything in the body of <code>effectiveError</code>, either if you're throwing or returning a valid result will be wrapped properly.</p> <p>You can find all the methods and an example in this gist: <a href=https://gist.github.com/AlexRex/e0a7aaa9246ad35707d4967f28156939>https://gist.github.com/AlexRex/e0a7aaa9246ad35707d4967f28156939</a></p> <p>Btw, if you're not new to functional programming paradigms, you probably noticed this is just a simplification of the Either monad with other name.</div></div></main> <div class=svelte-1p9jtq9>2021 Alex Torres</div></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{html:"\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Econst neverFailFunction = (input: number): number =&gt; {\n  if (input === 0) {\n    throw new Error('Oops, I failed')\n  }\n\n  return input * 2\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EOne day, you or a colleague are using this function, you check the signature, and you see this \u003Ccode\u003E(input: number) =&gt; number\u003C\u002Fcode\u003E, so why should this fail?\u003C\u002Fp\u003E\n\u003Cp\u003EObviously, this is not production code. But these things happens, you write a function that shouldn't fail, except for that particular edge case, time goes one, you forget about that case, and you use it without a \u003Ccode\u003Etrycatch\u003C\u002Fcode\u003E statement. You might catch the error it somewhere in the stack, probably some layers upwards, and most of the time it's probably too late, you're missing a lot of context to treat the error properly.\u003C\u002Fp\u003E\n\u003Cp\u003ESo what can we do to improve this? As of today, \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002FTypeScript\u002Fissues\u002F13219\"\u003ETypescript is still missing checked exceptions\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EIf we'd had checked exceptions, we could write our function like this:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Econst neverFailFunction = (input: number): number throws Error =&gt; {\n  if (input === 0) {\n    throw new Error('Oops, I failed')\n  }\n\n  return input * 2\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESo we could easily take a look at the signature and know that this function may throw an error \u003Ccode\u003E(input: number) =&gt; number throws Error\u003C\u002Fcode\u003E. We could even enable a flag in the compiler in order to fail if we don't wrap throwable functions with \u003Ccode\u003Etrycatch\u003C\u002Fcode\u003E clauses.\u003C\u002Fp\u003E\n\u003Cp\u003ESo we will be enforced to treat the error where the error happens, with all the context needed.\u003C\u002Fp\u003E\n\u003Cp\u003EUntil this becomes possible, if it ever happens, we can rely on other cool feature of Typescript: \u003Cstrong\u003EUnion Types\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\n\u003Ch3 id=\"union-types-as-result-types\"\u003EUnion Types as Result Types\u003C\u002Fh3\u003E\n\u003Cp\u003EFrom Typescript documentation:\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n  \u003Cp\u003EA union type describes a value that can be one of several types. We use the vertical bar (|) to separate each type, so \u003Ccode\u003Enumber | string | boolean\u003C\u002Fcode\u003E is the type of a value that can be a \u003Ccode\u003Enumber\u003C\u002Fcode\u003E, a \u003Ccode\u003Estring\u003C\u002Fcode\u003E, or a \u003Ccode\u003Eboolean\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EGreat! Let's use this in our function:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Econst neverFailFunction = (input: number): number | Error =&gt; {\n  if (input === 0) {\n    return new Error('Oops, I failed')\n  }\n\n  return input * 2\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAnd we can use it like this:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Econst otherFunction = (): void =&gt; {\n  const result = neverFailFunction(1)\n\n  if (result instanceof Error) {\n    return console.error(result.message)\n  }\n\n  console.log('it worked', result) \u002F\u002F it worked 1\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis looks much nicer now. We have the full potential of Typescript, we returned an \u003Ccode\u003Enumber | Error\u003C\u002Fcode\u003E but we could be doing something like \u003Ccode\u003Enumber | ValidationError | InternalError\u003C\u002Fcode\u003E so we have really specialized errors instead of a generic \u003Ccode\u003EError\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EIn the project I am currently working on we're using this approach a lot, but in order to even improve further the developer experience, we added some helper functions to make it easier work with external libraries and our own functions.\u003C\u002Fp\u003E\n\u003Cp\u003EFirst, we wrapped our functions results into a \u003Ccode\u003EResult\u003C\u002Fcode\u003E type:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Eexport class ApplicationError extends Error {\n  constructor(\n    public readonly errorCode: string,\n    description?: string\n  ) {\n    super(description || errorCode)\n\n    \u002F\u002F Need to override the prototype\n    \u002F\u002F https:\u002F\u002Fgithub.com\u002FMicrosoft\u002FTypeScript\u002Fwiki\u002FBreaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, ApplicationError.prototype)\n  }\n}\n\nexport const fromError = (error: Error) =&gt; new ApplicationError('INTERNAL_ERROR', error.message)\n\nexport type Ok&lt;T&gt; = {\n  value: T\n}\n\nexport const ok = &lt;T&gt;(data: T): Ok&lt;T&gt; =&gt; ({\n  value: data\n})\n\nexport type Result&lt;T, E extends ApplicationError = ApplicationError&gt; = Ok&lt;T&gt; | E\nexport type PromiseResult&lt;T, E extends ApplicationError = ApplicationError&gt; = Promise&lt;Result&lt;T, E&gt;&gt;\n\nexport const isErrorResult = &lt;T = unknown, E extends ApplicationError = ApplicationError&gt;(result: Result&lt;T, E&gt;): result is E =&gt;\n  'errorCode' in result\n\nexport const isOkResult = &lt;T = unknown, E extends ApplicationError = ApplicationError&gt;(result: Result&lt;T, E&gt;): result is Ok&lt;T&gt; =&gt;\n  'value' in result\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESo our function will become:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Econst neverFailFunction = (input: number): Result&lt;number, ApplicationError&gt; =&gt; {\n  if (input === 0) {\n    return new ApplicationError('Oops, I failed')\n  }\n\n  return ok(input * 2)\n}\n\nconst otherFunction = (): void =&gt; {\n  const result = neverFailFunction(1)\n\n  if (isErrorResult(result)) {\n    return console.error(result.message)\n  }\n\n  console.log('it worked', result.value) \u002F\u002F it worked 1\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAnd finally, what if we have a native or 3rd party library that may throw an error? ðŸ¤” Well, we created also some useful helper methods to wrap those functions and translate the output to a result type, even if it throws an error:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003E\u002F**\n * Expects a function that may throw. If it throws it returns the error passed\n *\u002F\nexport const fromAsyncTryCatch = &lt;O extends Error = Error, E extends ApplicationError = ApplicationError&gt;(errorFn: (originalError: O) =&gt; E) =&gt;\n  async &lt;DataType&gt;(fn: () =&gt; Promise&lt;DataType&gt;): PromiseResult&lt;DataType, E&gt; =&gt; {\n    try {\n      const res = await fn()\n\n      return ok&lt;DataType&gt;(res)\n    } catch (catchErr) {\n      return errorFn(catchErr)\n    }\n  }\n\nexport const fromTryCatch = &lt;O extends Error = Error, E extends ApplicationError = ApplicationError&gt;(errorFn: (originalError: O) =&gt; E) =&gt;\n  &lt;DataType&gt;(fn: () =&gt; DataType): Result&lt;DataType, E&gt; =&gt; {\n    try {\n      const res = fn()\n\n      return ok&lt;DataType&gt;(res)\n    } catch (catchErr) {\n      return errorFn(catchErr)\n    }\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESo for instance, a common thing that throws is \u003Ccode\u003EJSON.parse\u003C\u002Fcode\u003E, so we could use it as:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Econst parse = &lt;T&gt;(toParse: string): Result&lt;T, ApplicationError&gt; =&gt; fromTryCatch(\n  (error) =&gt; new ApplicationError('JSON parse failed', error.message)\n)(() =&gt; JSON.parse(toParse))\n\nconst parsedResult = parse&lt;{ foo: number }&gt;('{\"foo\":1}')\n\nif (isErrorResult(parsedResult)) {\n  return console.log('hack')\n}\n\nconsole.log(parsedResult.value.foo)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAnd to even make this easier, so we can avoid all the boilerplate, we added one more function:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Eexport const effectiveError = fromAsyncTryCatch&lt;Error | ApplicationError, ApplicationError&gt;(\n  (error) =&gt; {\n    if (error instanceof ApplicationError) {\n      return error\n    }\n\n    return fromError(error)\n  }\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis is pretty handy, so you don't even need to think of wrapping your stuff into a Result:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"typescript language-typescript\"\u003Econst parseAndProcess = &lt;T&gt;(toParse: string): PromiseResult&lt;T, ApplicationError&gt; =&gt;\n  effectiveError(async () =&gt; {\n    const parsedResult = JSON.parse(toParse)\n\n    console.log(parsedResult.foo)\n\n    if (parsedResult.foo === 1) {\n      throw new ApplicationError('hack')\n    }\n\n    return parsedResult\n  })\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESo you don't really need to care about wrapping or returning \u003Ccode\u003EOk\u003C\u002Fcode\u003E, everything in the body of \u003Ccode\u003EeffectiveError\u003C\u002Fcode\u003E, either if you're throwing or returning a valid result will be wrapped properly.\u003C\u002Fp\u003E\n\u003Cp\u003EYou can find all the methods and an example in this gist: \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002FAlexRex\u002Fe0a7aaa9246ad35707d4967f28156939\"\u003Ehttps:\u002F\u002Fgist.github.com\u002FAlexRex\u002Fe0a7aaa9246ad35707d4967f28156939\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EBtw, if you're not new to functional programming paradigms, you probably noticed this is just a simplification of the Either monad with other name.\u003C\u002Fp\u003E",metadata:{title:"Error handling in Typescript",summary:"Stop throwing errors and expecting someone will treat them",date:"2021-08-25T00:00:00.000Z",tags:"typescript, software-development",draft:false,slug:"error-handling-in-typescript"},filename:"error-handling-in-typescript.md",path:"\u002Fhome\u002Frunner\u002Fwork\u002Falextorres.me\u002Falextorres.me\u002Fsrc\u002Fposts\u002Ferror-handling-in-typescript.md"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.fefb9cd2.js"}catch(e){main="/client/legacy/client.f39193f8.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> 