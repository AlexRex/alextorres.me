{"html":"<pre><code class=\"typescript language-typescript\">const neverFailFunction = (input: number): number =&gt; {\n  if (input === 0) {\n    throw new Error('Oops, I failed')\n  }\n\n  return input * 2\n}</code></pre>\n<p>One day, you or a colleague are using this function, you check the signature, and you see this <code>(input: number) =&gt; number</code>, so why should this fail?</p>\n<p>Obviously, this is not production code. But these things happens, you write a function that shouldn't fail, except for that particular edge case, time goes one, you forget about that case, and you use it without a <code>trycatch</code> statement. You might catch the error it somewhere in the stack, probably some layers upwards, and most of the time it's probably too late, you're missing a lot of context to treat the error properly.</p>\n<p>So what can we do to improve this? As of today, <a href=\"https://github.com/microsoft/TypeScript/issues/13219\">Typescript is still missing checked exceptions</a></p>\n<p>If we'd had checked exceptions, we could write our function like this:</p>\n<pre><code class=\"typescript language-typescript\">const neverFailFunction = (input: number): number throws Error =&gt; {\n  if (input === 0) {\n    throw new Error('Oops, I failed')\n  }\n\n  return input * 2\n}</code></pre>\n<p>So we could easily take a look at the signature and know that this function may throw an error <code>(input: number) =&gt; number throws Error</code>. We could even enable a flag in the compiler in order to fail if we don't wrap throwable functions with <code>trycatch</code> clauses.</p>\n<p>So we will be enforced to treat the error where the error happens, with all the context needed.</p>\n<p>Until this becomes possible, if it ever happens, we can rely on other cool feature of Typescript: <strong>Union Types</strong>.</p>\n<h3 id=\"union-types-as-result-types\">Union Types as Result Types</h3>\n<p>From Typescript documentation:</p>\n<blockquote>\n  <p>A union type describes a value that can be one of several types. We use the vertical bar (|) to separate each type, so <code>number | string | boolean</code> is the type of a value that can be a <code>number</code>, a <code>string</code>, or a <code>boolean</code>.</p>\n</blockquote>\n<p>Great! Let's use this in our function:</p>\n<pre><code class=\"typescript language-typescript\">const neverFailFunction = (input: number): number | Error =&gt; {\n  if (input === 0) {\n    return new Error('Oops, I failed')\n  }\n\n  return input * 2\n}</code></pre>\n<p>And we can use it like this:</p>\n<pre><code class=\"typescript language-typescript\">const otherFunction = (): void =&gt; {\n  const result = neverFailFunction(1)\n\n  if (result instanceof Error) {\n    return console.error(result.message)\n  }\n\n  console.log('it worked', result) // it worked 1\n}</code></pre>\n<p>This looks much nicer now. We have the full potential of Typescript, we returned an <code>number | Error</code> but we could be doing something like <code>number | ValidationError | InternalError</code> so we have really specialized errors instead of a generic <code>Error</code>.</p>\n<p>In the project I am currently working on we're using this approach a lot, but in order to even improve further the developer experience, we added some helper functions to make it easier work with external libraries and our own functions.</p>\n<p>First, we wrapped our functions results into a <code>Result</code> type:</p>\n<pre><code class=\"typescript language-typescript\">export class ApplicationError extends Error {\n  constructor(\n    public readonly errorCode: string,\n    description?: string\n  ) {\n    super(description || errorCode)\n\n    // Need to override the prototype\n    // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, ApplicationError.prototype)\n  }\n}\n\nexport const fromError = (error: Error) =&gt; new ApplicationError('INTERNAL_ERROR', error.message)\n\nexport type Ok&lt;T&gt; = {\n  value: T\n}\n\nexport const ok = &lt;T&gt;(data: T): Ok&lt;T&gt; =&gt; ({\n  value: data\n})\n\nexport type Result&lt;T, E extends ApplicationError = ApplicationError&gt; = Ok&lt;T&gt; | E\nexport type PromiseResult&lt;T, E extends ApplicationError = ApplicationError&gt; = Promise&lt;Result&lt;T, E&gt;&gt;\n\nexport const isErrorResult = &lt;T = unknown, E extends ApplicationError = ApplicationError&gt;(result: Result&lt;T, E&gt;): result is E =&gt;\n  'errorCode' in result\n\nexport const isOkResult = &lt;T = unknown, E extends ApplicationError = ApplicationError&gt;(result: Result&lt;T, E&gt;): result is Ok&lt;T&gt; =&gt;\n  'value' in result</code></pre>\n<p>So our function will become:</p>\n<pre><code class=\"typescript language-typescript\">const neverFailFunction = (input: number): Result&lt;number, ApplicationError&gt; =&gt; {\n  if (input === 0) {\n    return new ApplicationError('Oops, I failed')\n  }\n\n  return ok(input * 2)\n}\n\nconst otherFunction = (): void =&gt; {\n  const result = neverFailFunction(1)\n\n  if (isErrorResult(result)) {\n    return console.error(result.message)\n  }\n\n  console.log('it worked', result.value) // it worked 1\n}</code></pre>\n<p>And finally, what if we have a native or 3rd party library that may throw an error? ðŸ¤” Well, we created also some useful helper methods to wrap those functions and translate the output to a result type, even if it throws an error:</p>\n<pre><code class=\"typescript language-typescript\">/**\n * Expects a function that may throw. If it throws it returns the error passed\n */\nexport const fromAsyncTryCatch = &lt;O extends Error = Error, E extends ApplicationError = ApplicationError&gt;(errorFn: (originalError: O) =&gt; E) =&gt;\n  async &lt;DataType&gt;(fn: () =&gt; Promise&lt;DataType&gt;): PromiseResult&lt;DataType, E&gt; =&gt; {\n    try {\n      const res = await fn()\n\n      return ok&lt;DataType&gt;(res)\n    } catch (catchErr) {\n      return errorFn(catchErr)\n    }\n  }\n\nexport const fromTryCatch = &lt;O extends Error = Error, E extends ApplicationError = ApplicationError&gt;(errorFn: (originalError: O) =&gt; E) =&gt;\n  &lt;DataType&gt;(fn: () =&gt; DataType): Result&lt;DataType, E&gt; =&gt; {\n    try {\n      const res = fn()\n\n      return ok&lt;DataType&gt;(res)\n    } catch (catchErr) {\n      return errorFn(catchErr)\n    }\n  }</code></pre>\n<p>So for instance, a common thing that throws is <code>JSON.parse</code>, so we could use it as:</p>\n<pre><code class=\"typescript language-typescript\">const parse = &lt;T&gt;(toParse: string): Result&lt;T, ApplicationError&gt; =&gt; fromTryCatch(\n  (error) =&gt; new ApplicationError('JSON parse failed', error.message)\n)(() =&gt; JSON.parse(toParse))\n\nconst parsedResult = parse&lt;{ foo: number }&gt;('{\"foo\":1}')\n\nif (isErrorResult(parsedResult)) {\n  return console.log('hack')\n}\n\nconsole.log(parsedResult.value.foo)</code></pre>\n<p>And to even make this easier, so we can avoid all the boilerplate, we added one more function:</p>\n<pre><code class=\"typescript language-typescript\">export const effectiveError = fromAsyncTryCatch&lt;Error | ApplicationError, ApplicationError&gt;(\n  (error) =&gt; {\n    if (error instanceof ApplicationError) {\n      return error\n    }\n\n    return fromError(error)\n  }\n)</code></pre>\n<p>This is pretty handy, so you don't even need to think of wrapping your stuff into a Result:</p>\n<pre><code class=\"typescript language-typescript\">const parseAndProcess = &lt;T&gt;(toParse: string): PromiseResult&lt;T, ApplicationError&gt; =&gt;\n  effectiveError(async () =&gt; {\n    const parsedResult = JSON.parse(toParse)\n\n    console.log(parsedResult.foo)\n\n    if (parsedResult.foo === 1) {\n      throw new ApplicationError('hack')\n    }\n\n    return parsedResult\n  })</code></pre>\n<p>So you don't really need to care about wrapping or returning <code>Ok</code>, everything in the body of <code>effectiveError</code>, either if you're throwing or returning a valid result will be wrapped properly.</p>\n<p>You can find all the methods and an example in this gist: <a href=\"https://gist.github.com/AlexRex/e0a7aaa9246ad35707d4967f28156939\">https://gist.github.com/AlexRex/e0a7aaa9246ad35707d4967f28156939</a></p>\n<p>Btw, if you're not new to functional programming paradigms, you probably noticed this is just a simplification of the Either monad with other name.</p>","metadata":{"title":"Error handling in Typescript","summary":"Stop throwing errors and expecting someone will treat them","date":"2021-08-25T00:00:00.000Z","tags":"typescript, software-development","draft":false,"slug":"error-handling-in-typescript"},"filename":"error-handling-in-typescript.md","path":"/home/runner/work/alextorres.me/alextorres.me/src/posts/error-handling-in-typescript.md"}